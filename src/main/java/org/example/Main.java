package org.example;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.*;

public class Main {
    private final static ArrayList<User> users=new ArrayList<>();
    private final static User currentUser=new User("","",null);
    private final static int passwordLength=5;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Register a new user
        System.out.println("enter your username:");
        String newUsername=scanner.nextLine();
        System.out.println("Create a new password:");
        String newPassword = scanner.nextLine();
        registerUser(newPassword,newUsername);

        // Prompt for password verification
        System.out.println("Enter your username for verification:");
        String enteredUsername=scanner.nextLine();
        System.out.println("Enter your password for verification:");
        String enteredPassword = scanner.nextLine();
        if (verifyPassword(enteredPassword,enteredUsername)) {
            System.out.println("Password verified successfully!");
        } else {
            System.out.println("Password verification failed.");
        }

        List<String> passwords= Utility.generatePasswordsOfLength(passwordLength);
        HashMap<String,String> plainAndHash=new HashMap<>();
        for(String password:passwords){plainAndHash.put(password,hashPassword(password,toPrimitiveByteArray(currentUser.getSalt())));}
        String foundPassword;
        for (Map.Entry<String, String> entry : plainAndHash.entrySet()) {
            if (entry.getValue().equals(currentUser.getHashedPassword())) {
                foundPassword = entry.getKey();
                System.out.println("the password is: "+foundPassword);
                break;
            }
        }

        scanner.close();
        System.exit(1);
    }

    private static void registerUser(String password,String username) {
        // Generate a random salt
        // the secure random is choosing 16 bytes meaning 16 numbers which each
        // one is in the range of 127 to -128 and it does so with less predictability then
        // the usual random which i guess takes a bit more time and that is why you dont always use secure random.
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        random.nextBytes(salt);

        // Hash the password with salt
        String hashedPassword = hashPassword(password, salt);
        currentUser.setHashedPassword(hashedPassword);
        currentUser.setSalt(toByteObjectArray(salt));
        currentUser.setUsername(username);
        users.add(currentUser);
    }

    private static boolean verifyPassword(String password, String username) {
        for (User user:users) {
            if(username.equals(user.getUsername())){
                 if(password.equals(user.getHashedPassword())){
                    System.out.println("we suspect you are not the owner of the account...");
                    return false;
                }
                String hashedPassword = hashPassword(password,toPrimitiveByteArray(user.getSalt()));
                if (hashedPassword.equals(user.getHashedPassword())) {
                    return true; // Password matches
                }
            }
        }
        return false; // No match found
    }

    private static String hashPassword(String password, byte[] salt) {
        try {
            //the messageDigest is representing the hash algorithm we have chosen.
            // It provides applications the functionality of a message digest algorithm, such as SHA-256.
            // Message digest algorithms are used to produce a fixed-size hash value from arbitrary-length data (like a password).
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            //we are giving the hash algorithm an additional bytes (the ones generated by secure random) to hash along with the plain text password.
            digest.update(salt);
            //breaks the password into bytes and digest it along with the salt bytes which are already in the MessageDigest  from the previous line and now they are hashed.
            byte[] encodedHash = digest.digest(password.getBytes());

            StringBuilder hexString = new StringBuilder();
            //we go through all the bytes that were hashed and covert them into a hexadecimal string.
            //we do this part for convenience reasons.
            for (byte b : encodedHash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }
            System.out.println(hexString.toString());
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    private static Byte[] toByteObjectArray(byte[] bytesPrimitive) {
        // in this method we turn byte from its primitive type into its wrapper class type by
        // creating a wrapper class array and passing to it the bytes from the primitive type array.
        Byte[] bytesObject = new Byte[bytesPrimitive.length];
        int i = 0;
        for (byte b : bytesPrimitive) {
            bytesObject[i++] = b; // Autoboxing primitive byte to Byte object
        }
        return bytesObject;
    }

    private static byte[] toPrimitiveByteArray(Byte[] bytesObject) {
        //in this method we turn byte from its wrapper class type into its primitive type by
        //creating a primitive type array and passing to it the bytes from the wrapper class array.
        byte[] bytesPrimitive = new byte[bytesObject.length];
        int i = 0;
        for (Byte b : bytesObject) {
            bytesPrimitive[i++] = b; // Unboxing Byte object to primitive byte
        }
        return bytesPrimitive;
    }
}
